from browser import document, html, timer

# å…¨åŸŸå¸¸æ•¸
CELL_SIZE = 40
WALL_THICKNESS = 6
IMG_PATH = "https://mde.tw/cp2025/reeborg/src/images/"
WORLD_SIZE = 10

class World:
    """å®šç¾©ä¸–ç•Œï¼ŒåŒ…å«ç¶²æ ¼ã€ç‰†å£å’Œç‰©ä»¶çš„ç¹ªåœ–å±¤ã€‚"""
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.layers = self._create_layers()
        self._init_html()
        self._draw_grid()
        self._draw_walls()
        self._image_cache = {} # æ–°å¢åœ–ç‰‡å¿«å–

    def _create_layers(self):
        # ç¹ªåœ–å±¤å¾ä¸‹åˆ°ä¸Š (zIndex: 0-3)
        return {
            "grid": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
            "walls": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
            "objects": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE), # ç”¨æ–¼ç¹ªè£½ç§»å‹•è»Œè·¡
            "robots": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
        }

    def _init_html(self):
        container = html.DIV(style={
            "position": "relative",
            "width": f"{self.width * CELL_SIZE}px",
            "height": f"{self.height * CELL_SIZE}px",
            "border": f"{WALL_THICKNESS}px solid #333", # ç‚ºé‚Šç•Œå¢åŠ å¯¦é«”é‚Šæ¡†
            "boxSizing": "content-box" # ç¢ºä¿é‚Šæ¡†ä¸å½±éŸ¿å¤§å°è¨ˆç®—
        })
        for z, canvas in enumerate(self.layers.values()):
            canvas.style = {
                "position": "absolute",
                "top": "0px",
                "left": "0px",
                "zIndex": str(z)
            }
            container <= canvas
        document["brython_div1"].clear()
        document["brython_div1"] <= container

    def _draw_grid(self):
        ctx = self.layers["grid"].getContext("2d")
        ctx.strokeStyle = "#cccccc"
        for i in range(self.width + 1):
            ctx.beginPath()
            ctx.moveTo(i * CELL_SIZE, 0)
            ctx.lineTo(i * CELL_SIZE, self.height * CELL_SIZE)
            ctx.stroke()
        for j in range(self.height + 1):
            ctx.beginPath()
            ctx.moveTo(0, j * CELL_SIZE)
            ctx.lineTo(self.width * CELL_SIZE, j * CELL_SIZE)
            ctx.stroke()

    def _draw_image(self, ctx, src, x, y, w, h, offset_x=0, offset_y=0, callback=None):
        """
        ç¹ªè£½åœ–ç‰‡åˆ°æŒ‡å®šä½ç½®ï¼Œä½¿ç”¨å¿«å–ç¢ºä¿åªè¼‰å…¥ä¸€æ¬¡ï¼Œä¸¦æ”¯æ´å›å‘¼å‡½æ•¸ã€‚
        x, y æ˜¯æ©Ÿå™¨äººåæ¨™ (å¾ 0, 0 é–‹å§‹)
        """
        px = x * CELL_SIZE + offset_x
        py = (self.height - 1 - y) * CELL_SIZE + offset_y
        
        # æª¢æŸ¥å¿«å–
        if src in self._image_cache:
            img = self._image_cache[src]
            ctx.drawImage(img, px, py, w, h)
            # å¦‚æœåœ–ç‰‡å·²åœ¨å¿«å–ä¸­ï¼Œå›å‘¼å¯ä»¥ç«‹å³åŸ·è¡Œ (ä½¿ç”¨ timer.set_timeout é¿å…é˜»å¡)
            if callback:
                 timer.set_timeout(callback, 0)
            return

        # é¦–æ¬¡è¼‰å…¥
        img = html.IMG()
        img.src = src
        self._image_cache[src] = img

        def onload(evt):
            # è¼‰å…¥å®Œæˆå¾Œç¹ªè£½
            ctx.drawImage(img, px, py, w, h)
            if callback:
                callback() # åœ–ç‰‡è¼‰å…¥å¾ŒåŸ·è¡Œå›å‘¼
            
        img.bind("load", onload)

    def _draw_walls(self):
        # ç¹ªè£½å¤–ç‰†ï¼Œè®“é‚Šç•Œæª¢æŸ¥é‚è¼¯æ›´ç›´è§€
        ctx = self.layers["walls"].getContext("2d")
        
        # ç‚ºäº†ä¿æŒåŸç¨‹å¼ç¢¼çš„é¢¨æ ¼ï¼Œé‚„æ˜¯ç¹ªè£½åœ–ç‰‡ç‰†
        # ç§»é™¤å…§å»ºçš„é‚Šç•Œç‰†ï¼Œè®“æ©Ÿå™¨äººå¯ä»¥æ’åˆ°é‚Šç•Œ
        pass

    def robot(self, x, y):
        # åˆå§‹æ”¾ç½®æ©Ÿå™¨äºº (ç”¨æ–¼éœæ…‹ä¸–ç•Œï¼Œä½†æˆ‘å€‘ä½¿ç”¨ AnimatedRobotï¼Œæ‰€ä»¥é€™è¡Œä¸æœƒè¢«ç”¨åˆ°)
        pass

class AnimatedRobot:
    """å¯å‹•ç•«ç§»å‹•çš„æ©Ÿå™¨äººã€‚"""
    def __init__(self, world, x, y):
        # å°‡ (1, 1) è½‰æ›ç‚ºå…§éƒ¨åº§æ¨™ (0, 0)
        self.world = world
        self.x = x - 1
        self.y = y - 1
        self.facing = "E" # åˆå§‹é¢æ±
        self.facing_order = ["E", "N", "W", "S"] # é€†æ™‚é‡é †åº
        self.robot_ctx = world.layers["robots"].getContext("2d")
        self.trace_ctx = world.layers["objects"].getContext("2d")
        self.queue = []
        self.running = False
        self.world_width = world.width
        self.world_height = world.height
        self._is_ready = False # æ–°å¢æ——æ¨™ï¼šæ©Ÿå™¨äººæ˜¯å¦å·²æˆåŠŸç¹ªè£½åˆå§‹åœ–ç‰‡

        # åˆå§‹ç¹ªè£½ï¼Œä¸¦åœ¨åœ–ç‰‡è¼‰å…¥å¾Œå°‡ _is_ready è¨­ç‚º True
        self._draw_robot(initial_draw=True) 

    def _robot_image(self):
        return {
            "E": "blue_robot_e.png",
            "N": "blue_robot_n.png",
            "W": "blue_robot_w.png",
            "S": "blue_robot_s.png"
        }[self.facing]

    def _draw_robot(self, initial_draw=False):
        """æ¸…é™¤èˆŠä½ç½®ä¸¦åœ¨ç›®å‰ä½ç½®ç¹ªè£½æ©Ÿå™¨äººã€‚"""
        self.robot_ctx.clearRect(0, 0, self.world_width * CELL_SIZE, self.world_height * CELL_SIZE)
        
        def initial_draw_complete():
            """åœ¨ç¬¬ä¸€æ¬¡æˆåŠŸç¹ªè£½å¾Œå‘¼å«ï¼Œæ¨™è¨˜æ©Ÿå™¨äººå·²æº–å‚™å¥½åŸ·è¡Œå‹•ç•«ä½‡åˆ—ã€‚"""
            if initial_draw and not self._is_ready:
                self._is_ready = True
                self._run_queue() # åœ–ç‰‡è¼‰å…¥å®Œæˆå¾Œï¼Œæ­£å¼å•Ÿå‹•ä½‡åˆ—

        self.world._draw_image(self.robot_ctx, IMG_PATH + self._robot_image(),
                               self.x, self.y, CELL_SIZE, CELL_SIZE, callback=initial_draw_complete if initial_draw else None)

    def _draw_trace(self, from_x, from_y, to_x, to_y):
        """ç¹ªè£½å¾ (from_x, from_y) åˆ° (to_x, to_y) çš„è»Œè·¡ç·šã€‚"""
        ctx = self.trace_ctx
        ctx.strokeStyle = "#d33"
        ctx.lineWidth = 2
        ctx.beginPath()
        
        # è½‰æ›åº§æ¨™ (Brython canvas çš„ y è»¸æ˜¯åè½‰çš„)
        fx = from_x * CELL_SIZE + CELL_SIZE / 2
        fy = (self.world_height - 1 - from_y) * CELL_SIZE + CELL_SIZE / 2
        tx = to_x * CELL_SIZE + CELL_SIZE / 2
        ty = (self.world_height - 1 - to_y) * CELL_SIZE + CELL_SIZE / 2
        
        ctx.moveTo(fx, fy)
        ctx.lineTo(tx, ty)
        ctx.stroke()

    def move(self, steps):
        """å°‡ç§»å‹•å‹•ä½œåŠ å…¥ä½‡åˆ—ã€‚"""
        def action(next_done):
            # é€™æ˜¯å…§éƒ¨å‡½æ•¸ï¼Œè™•ç†æ¯ä¸€æ­¥çš„å‹•ç•«
            def step():
                nonlocal steps
                if steps == 0:
                    next_done() # å‹•ä½œå®Œæˆï¼ŒåŸ·è¡Œä¸‹ä¸€å€‹ä½‡åˆ—ä¸­çš„å‹•ä½œ
                    return

                from_x, from_y = self.x, self.y
                dx, dy = 0, 0
                
                # æ ¹æ“šæœå‘æ±ºå®šç§»å‹•æ–¹å‘
                if self.facing == "E": dx = 1
                elif self.facing == "W": dx = -1
                elif self.facing == "N": dy = 1
                elif self.facing == "S": dy = -1

                next_x = self.x + dx
                next_y = self.y + dy
            
                # é‚Šç•Œæª¢æŸ¥ï¼šç¢ºä¿æ–°ä½ç½®åœ¨ä¸–ç•Œç¯„åœå…§
                if 0 <= next_x < self.world_width and 0 <= next_y < self.world_height:
                    self.x, self.y = next_x, next_y
                    self._draw_trace(from_x, from_y, self.x, self.y)
                    self._draw_robot() # æ¯æ¬¡ç§»å‹•éƒ½ç¹ªè£½æ©Ÿå™¨äºº (ç¾åœ¨æœƒä½¿ç”¨å¿«å–)
                    steps -= 1
                    timer.set_timeout(step, 100) # æ¯æ¬¡ç§»å‹•é–“éš” 100ms
                else:
                    print("ğŸš¨ å·²ç¶“æ’ç‰†ï¼Œåœæ­¢ç§»å‹•ï¼")
                    next_done() # æ’ç‰†ä¹Ÿç®—å‹•ä½œå®Œæˆ

            step() # é–‹å§‹ç§»å‹•æ­¥é©Ÿ
            
        self.queue.append(action)
        self._run_queue()

    def turn_left(self):
        """å°‡å·¦è½‰å‹•ä½œåŠ å…¥ä½‡åˆ— (é€†æ™‚é‡ 90 åº¦)ã€‚"""
        def action(done):
            idx = self.facing_order.index(self.facing)
            self.facing = self.facing_order[(idx + 1) % 4]
            self._draw_robot() # è½‰å‘å¾Œç¹ªè£½æ©Ÿå™¨äºº (ç¾åœ¨æœƒä½¿ç”¨å¿«å–)
            timer.set_timeout(done, 150) # è½‰å½é–“éš” 150ms

        self.queue.append(action)
        self._run_queue()

    def _run_queue(self):
        """å¦‚æœæ²’æœ‰æ­£åœ¨é‹è¡Œçš„å‹•ä½œä¸”ä½‡åˆ—ä¸ç‚ºç©ºï¼Œå‰‡é–‹å§‹åŸ·è¡Œä½‡åˆ—ä¸­çš„ä¸‹ä¸€å€‹å‹•ä½œã€‚"""
        # åƒ…ç•¶æ©Ÿå™¨äººåˆå§‹åœ–ç‰‡è¼‰å…¥å®Œç•¢å¾Œï¼Œæ‰åŸ·è¡Œä½‡åˆ—å‹•ä½œ
        if not self._is_ready:
            return

        if self.running or not self.queue:
            return
            
        self.running = True
        action = self.queue.pop(0)
        action(lambda: self._done())

    def _done(self):
        """å‹•ä½œå®Œæˆå¾Œå‘¼å«ï¼Œæº–å‚™åŸ·è¡Œä¸‹ä¸€å€‹å‹•ä½œã€‚"""
        self.running = False
        self._run_queue()

# --- ä¸–ç•Œèˆ‡æ©Ÿå™¨äººè¨­ç½® ---
w = World(WORLD_SIZE, WORLD_SIZE) # å»ºç«‹ 10x10 çš„ä¸–ç•Œ
r = AnimatedRobot(w, 1, 1)        # åœ¨ (1,1) æ”¾ç½®ä¸€å° robot (å…§éƒ¨åº§æ¨™ 0, 0)

# --- è›‡å½¢å·¡é‚é‚è¼¯ ---
# 10x10 ä¸–ç•Œæœ‰ 10 è¡Œ (i = 0 åˆ° 9)
for i in range(WORLD_SIZE):
    if i % 2 == 0:
        # å¶æ•¸è¡Œ (0, 2, 4, ...): å¾å·¦åˆ°å³ (æ±å‘ E) ç§»å‹• 9 æ­¥ (èµ° 10 æ ¼)
        r.move(WORLD_SIZE - 1) # 9 æ­¥
        
        # è½‰å‘ä¸‹ä¸€è¡Œ (å¦‚æœä¸æ˜¯æœ€å¾Œä¸€è¡Œ)
        if i < WORLD_SIZE - 1:
            r.turn_left() # E -> N (é¢åŒ—)
            r.move(1)     # åŒ—å‘ç§»å‹• 1 æ­¥ (ä¸Šç§»ä¸€å±¤)
            r.turn_left() # N -> W (é¢è¥¿ï¼Œæº–å‚™å›é ­)
    else:
        # å¥‡æ•¸è¡Œ (1, 3, 5, ...): å¾å³åˆ°å·¦ (è¥¿å‘ W) ç§»å‹• 9 æ­¥
        r.move(WORLD_SIZE - 1) # 9 æ­¥
        
        # è½‰å‘ä¸‹ä¸€è¡Œ (å¦‚æœä¸æ˜¯æœ€å¾Œä¸€è¡Œ)
        if i < WORLD_SIZE - 1:
            # åœ¨ (1, y) é¢è¥¿ï¼Œéœ€è¦è½‰ W -> N -> E (3 æ¬¡å·¦è½‰) æ‰èƒ½é¢åŒ—
            r.turn_left()
            r.turn_left()
            r.turn_left() # W -> N (é¢åŒ—)
            r.move(1)     # åŒ—å‘ç§»å‹• 1 æ­¥ (ä¸Šç§»ä¸€å±¤)
            
            # åœ¨ (1, y+1) é¢åŒ—ï¼Œéœ€è¦è½‰ N -> E (3 æ¬¡å·¦è½‰) æ‰èƒ½é¢æ±
            r.turn_left()
            r.turn_left()
            r.turn_left() # N -> E (é¢æ±ï¼Œæº–å‚™å‘å³)

# æœ€å¾Œä¸€è¡Œç§»å‹•å®Œç•¢ï¼Œä¸éœ€è¦å†è½‰å‘
